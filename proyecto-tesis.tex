% vim: set fileencoding=utf-8 encoding=utf-8 textwidth=80:
\documentclass[11pt,spanish]{article}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{fullpage}
\usepackage{url}
\usepackage{times}
\usepackage{mathptmx}
%\usepackage{mathrsfs} 
\usepackage{amsmath} 
%\usepackage{amssymb} 
%\usepackage{amsbsy} 
%\usepackage{cancel}
%\usepackage[dvips]{graphicx} 

\newcommand{\reftitle}{\textit}
\newcommand{\vel}{\mathbf{u}}
\newcommand{\vort}{\mathbf{\omega}}
\newcommand{\pos}{\mathbf{x}}

\title{Proyecto de Tesis \\
    Magíster en Ciencias de la Ingeniería Informática \\
    \textsc{Borrador \#2}
}
\author{Roberto Bonvallet}
\date{Noviembre de 2008}

\begin{document}
\maketitle
\thispagestyle{empty}
\begin{enumerate}
    \item \textbf{Título del Proyecto de Tesis:}
 
    \item \textbf{Nombre del Alumno:}
        Roberto Javier Bonvallet Carrasco
    \item \textbf{Número de Teléfono:}
        no tiene
         
    \item \textbf{E-mail:}
        \texttt{rbonvall@inf.utfsm.cl}
    \item \textbf{Fecha de ingreso al programa:}
        Primer semestre de 2006
    \item \textbf{Pregrado:}
        Licenciatura en Ingeniería Informática, UTFSM, 2006
    \item \textbf{Profesor guía de tesis:}
        Luis Salinas Carrasco
    \item \textbf{Fecha presentación tema de tesis:}
    \item \textbf{Fecha aprobación tema de tesis:}
    \item \textbf{Fecha tentativa de término:}
    \item \textbf{Comisión interna de graduación:}
\end{enumerate}

\newpage
\section*{Resumen}

\emph{Debe ser suficientemente informativo, y contener una síntesis del proyecto, sus
objetivos, resultados esperados y palabras claves. }



\paragraph{Palabras claves:}
computación de alto desempeño,
dinámica de fluídos computacional,
métodos de partículas,
métodos de vórtices,
computación en GPUs,
lenguajes de programación dinámicos.


\section*{Abstract}

\emph{Lo mismo, en inglés}

\paragraph{Key words:}
High Performance Computing,
Computational Fluid Dynamics,
Particle Methods,
Vortex Methods,
General Purpose GPU Programming,
Dynamic Programming Languages.

\newpage
\section{Formulación General de la Problemática y Propuesta de Tesis}

\emph{Debe contener la exposición general del problema, identificando claramente qué
aspectos relacionados con la informática son los más relevantes.  Además,
deberá contener el marco teórico, la discusión bibliográfica con sus
referencias y, finalmente, su propuesta de tesis.}
    
\emph{(La extensión máxima de esta sección es de hasta 5 páginas.  En hojas
adicionales incluya la lista de referencias)}

El trabajo de tesis propuesto consiste en el análisis, diseño e implementación
de componentes para hacer simulaciones de fluídos con métodos de partículas,
utilizando la GPU como recurso computacional, y ofreciendo una interfaz de alto
nivel en un lenguaje de programación dinámico.

\subsection{Computación de alto desempeño}

Desde los inicios de la computación, ha existido una demanda creciente de poder
computacional en las áreas de la ciencia y la ingeniería.  A medida que ha
aumentado la capacidad de cómputo disponible, también han crecido el tamaño y la
complejidad de los problemas que se necesita resolver, y en el caso de los
problemas más complejos, no es posible hacerlo en un tiempo razonable.
\cite{parallel-programming}

La computación de alto desempeño (HPC) es la utilización de supercomputadores y
clústers de computadores para resolver problemas computacionales complejos.  Los
conceptos claves en HPC son:
\begin{itemize}
   \item paralelismo:
     la capacidad de ejecutar instrucciones concurrentemente;
   \item escalabilidad:
     la capacidad de acomodarse a problemas de tamaño creciente;
   \item computación commodity:
     sistemas computacionales construídos con hardware
     estándar y de bajo costo, con componentes de software off-the-shelf
     (interoperabilidad).
\end{itemize}
La tendencia actual en sistemas de HPC y en diseño de arquitecturas de hardware
ya no apunta a mejorar el rendimiento de las unidades de cómputo por separado,
sino a explotar el paralelismo para obtener mejoras en el desempeño final de un
programa, a pesar de la carga adicional que significa manejar la concurrencia.
(preferir high throughput sobre high performance)
\cite{hpc-gpu-cuda-slides}

\subsection{Computación en hardware gráfico}
Las unidades de procesamiento gráfico (GPU) son componentes de hardware diseñados
originalmente para acelerar aplicaciones de computación gráfica (CG), que son
intensivas en cómputo y requieren resultados en tiempo real.  Las
características de una aplicación gráfica que pueden ser efectivamente
paralelizadas, y que son explotadas por la GPU, son:
\begin{itemize}
  \item stream processing:
    las operaciones visuales suelen ser independientes entre
    píxeles, y pueden ejecutarse concurrentemente;  destinando procesadores
    separados para cada operación es como las GPUs obtienen la mayor ganancia
    en desempeño~\cite[\S3.2]{gpupp};
  \item pipelining:
    las diferentes etapas de un algoritmo gráfico (p.ej.
    transformaciones espaciales, aplicación de texturas, rasterización)
    forman una estructura de tubería (pipeline), en que la salida de una etapa
    sirve de entrada a la siguiente;  las GPUs implementan este pipeline en
    hardware, ofreciendo cierto control sobre sus etapas~\cite[\S3.1]{pygpu};
  \item vector processing:
    casi todas las cantidades involucradas en computación
    gráfica son vectores (colores, puntos, segmentos, direccionamiento en
    texturas); por ello, las instrucciones de la GPU operan sobre 4-vectores de
    números de coma flotante, en lugar de sobre cantidades escalares.
    \cite[\S3.3]{gpupp}
\end{itemize}

En la última década, las GPUs han evolucionado rápidamente en términos de
capacidad computacional y de programabilidad.  Su capacidad de cómputo ya supera
por un orden de magnitud la de las CPUs~\cite{gpupp}.  Este poder computacional ha
incentivado el uso de GPUs para computación de propósito general, al punto que
ya se las considera una parte integral del repertorio de aplicaciones
HPC~\cite{gpu-computing}.

A medida que las GPUs se hacían más programables, también evolucionaron las
interfaces para programación.  Inicialmente, se programaban los procesadores de
vértices y de fragmentos a nivel de lenguaje de ensamblado.  Después aparecieron
lenguajes de más alto nivel como Cg, HLSL y GLslang, que sin embargo igual
utilizaban llamadas explícitas a las APIs gráficas.  Debido a esto, la
implementación de algoritmos de propósito general requería expresarlos en
función de directivas gráficas~\cite[\S2.2]{brookgpu}.  Programar la GPU
implicaba crear shaders, programas que pintan píxeles a partir de los
vértices, fragmentos y texturas que le sirven de entrada.

Las abstracciones gráficas (vértices, fragmentos, texturas, shaders)
son análogas a un paradigma más general denominado \emph{stream processing},
en que una serie de operaciones de cómputo (los kernels) son aplicados sobre
cada elemento de un conjunto de datos de entrada (el stream).  Este modelo es
incorporado en lenguajes para GPUs más recientes como Brook y CUDA.

A pesar de ofrecer modelos de programación cada vez más flexibles, las GPUs
siguen siendo un entorno de programación extremadamente limitado, y no cualquier
algoritmo es apropiado para ser acelerado en la GPU.  En particular, la
programación con streams incentiva aplicaciones con alta intensidad aritmética
(tasa de operaciones por ancho de banda de memoria)
~\cite[\S2.1]{brookgpu}.  Operaciones que son elementales en la CPU, como
ejecución condicional y acceso directo a memoria, no permiten explotar el
paralelismo y el ancho de banda de la GPU, e introducen penalizaciones de
rendimiento importantísimas~\cite[\S{}V.C]{gpu-computing}.

\subsection{Programación científica de alto nivel y las GPUs}
Tradicionalmente, la programación científica se caracteriza por sus
exigentes requerimientos de performance.  Las bibliotecas científicas suelen
estar implementadas en lenguajes compilados, típicamente C y Fortran, cuyos
compiladores realizan optimizaciones agresivas que permiten obtener binarios
extremadamente eficientes en términos de tiempo de ejecución, aprovechando al
máximo la arquitectura del computador.

Por otra parte, existen los lenguajes de programación dinámicos (p.ej.~Lisp,
Python, Ruby, Scheme) que están diseñados para aumentar la eficiencia
del programador.  Permiten ciclos de desarrollo más rápido, presentan
abstracciones más cercanas al programador que a la máquina, y ofrecen
facilidades de mateprogramación~\cite[\S2]{pygpu}.  Como consecuencia, los
programas suelen ser más fáciles de implementar, de mantener y de reutilizar, y
se adaptan mejor al esquema de trabajo de un programador científico, típicamente
orientado a refinar prototipos en varias iteraciones.

El precio del dinamismo es una altísima penalización en rendimiento.  Por esto,
los entornos de programación científicos dinámicos están diseñados para servir
de pegamento entre bibliotecas binarias altamente optimizadas.  Este esquema es
utilizado exitosamente, por ejemplo, por el lenguaje Matlab y por la biblioteca
Numpy en el lenguaje Python, lo que permite desarrollar aplicaciones científicas
completas de rendimiento aceptable sin necesidad de escribir código en un
lenguaje compilado.

Muy recientemente han aparecido sistemas para integrar la programación de GPUs
de manera transparente en lenguajes de alto nivel.

GPU++~\cite{gpupp} (2007) es un sistema de desarrollo integrado con C++ que
permite implementar y utilizar kernels abstrayendo tanto la GPU como la CPU.
Introduce varias técnicas de optimización, y administra en lugar del programador
la ejecución de código y el copiado de datos entre el procesador y la tarjeta
gráfica.

PyGPU++~\cite{pygpu} (2008) es una biblioteca para escribir funciones para la
GPU en Python. Utiliza las capacidades introspectivas del lenguaje,
introduciendo un decorador que examina el bytecode de la función y anotaciones
adicionales, y compila el código para la GPU.

PyCUDA~\cite{pycuda} (2008) es una biblioteca que permite acceder directamente a
la API de CUDA desde Python, ofreciendo además varias conveniencias adicionales,
como una estructura de datos para representar matrices y vectores, cuyas
operaciones son ejecutadas transparentemente en la GPU.


\subsection{Dinámica de fluídos computacional}
Una de las áreas de investigación que tradicionalmente ha tenido requerimientos
exigentes de poder de cómputo para hacer simulaciones es la dinámica de fluídos.
La dinámica de fluídos computacional tiene importantes aplicaciones industriales
en diversas áreas como la aeronáutica, la meteorología y la geología.

La dinámica de fluídos estudia los fluídos en movimiento.  Los problemas de la
dinámica de fluídos consisten en calcular varias propiedades del fluído (p.ej.
la velocidad $\vel$, la presión $p$, la densidad $\rho$, la temperatura $T$) en
todo el dominio del fluido, durante un intervalo de tiempo.  Estas propiedades
se llaman variables de estado, y están relacionadas por leyes de conservación y
ecuaciones de estado.

En general los problemas de dinámica de fluídos no se pueden resolver
analíticamente excepto en casos triviales.  La dinámica de fluídos computacional
(CFD) usa métodos numéricos para resolver estos problemas, que aun así siguen
siendo complejos:  incluso con ecuaciones simplificadas y usando recursos de
HPC, sólo es posible obtener soluciones aproximadas.

La ecuación más importante de la dinámica de fluídos es la ecuación de
Navier-Stokes, que describe la conservación de momentum en un fluido viscoso,
de manera análoga a la segunda ley de Newton.  
\begin{equation}
    \rho\left(\frac{\partial\vel}{\partial t} + \vel\cdot\nabla\vel \right) =
    \nu\Delta\vel - \nabla p + \mathbf{f}.
\end{equation}
El término $\rho(\vel\cdot\nabla\vel)$ es denominado aceleración convectiva, y
explica cómo cambia la velocidad con respecto a la posición en un instante de
tiempo fijo.  Este es el único término no lineal de la ecuación, lo que acarrea
problemas numéricos al discretizar el problema, y en la práctica representa el
principal aporte a la turbulencia del fluído.

La turbulencia es el comportamiento caótico observado en los fluídos.  Es un
fenómeno cuya naturaleza no está bien comprendida, y es difícil de cuantificar y
de describir.  Los métodos numéricos para fluídos turbulentos deben incorporar
algún tipo de modelo de turbulencia, generalmente con base experimental, para
dar cuenta de ella.  Además, la turbulencia emerge en varios niveles de escala,
lo que exige alta resolución en la discretización de los problemas, y por lo
tanto más poder computacional.

\subsection{Métodos de partículas}
La mayoría de los métodos de CFD discretizan el dominio del problema utilizando
algún tipo de malla.  Los métodos de partículas, en cambio, son una clase
de métodos que utilizan partículas discretas que arrastran distribuciones
localizadas de variables de estado por el fluído.  Las propiedades físicas del
fluído pueden ser recuperadas como una superposición de las distribuciones
de todas las partículas.

Los métodos de partículas están basados en la forma lagrangiana de las
ecuaciones subyacentes.  La forma lagrangiana utiliza como marco de referencia
las trayectorias de las partículas en el tiempo, y en ella no aparece el término
de aceleración convectiva.  Las ecuaciones pasan a ser un sistema de ecuaciones
diferenciales ordinarias:
\begin{align}
    \frac{d\pos_p}{dt} &= \vel_p(\pos_p, t) =
        \sum_{p'} \mathbf{K}(\pos_p, \pos_{p'}; \xi_p, \xi_{p'}) \\
    \frac{d\xi_p}{dt} &=
        \sum_{p'} \mathbf{F}(\pos_p, \pos_{p'}; \xi_p, \xi_{p'})
\end{align}
donde $\xi$ es alguna propiedad del fluído, y $\mathbf{K}$ y $\mathbf{F}$ 
representan la dinámica del sistema físico simulado.

Una clase importante de métodos de partículas son los métodos de vórtices (VM),
que han sido utilizados desde la década de 1930 para describir la evolución de
estructuras vorticales en flujos incompresibles~\cite[\S2.2]{multiscale}.  Los
VMs describen la evolución de la vorticidad $\vort = \nabla\times\vel$ del
fluído.  En cada iteración, es necesario recuperar la velocidad a partir de la
vorticidad para avanzar las partículas, y este paso es el más costoso en
términos computacionales.  Por otra parte, en muchos fluídos la vorticidad es
no nula sólo en una región reducida del dominio, lo que permite reducir el
número de partículas necesarias para la simulación.

Los métodos de vórtices han sido utilizados en aplicaciones de ingeniería,
sus resultados tienen buena concordancia con los experimentos, y se ha postulado
que su utilización introduce un modelo de turbulencia implícito.

Los métodos de partículas no fueron muy utilizados en la simulación de sistemas
continuos debido a dificultades numéricas y de implementación.  Trabajos
teóricos recientes han abordado exitosamente los problemas numéricos, y han
demostrado las ventajas de estos métodos:  adaptividad, capacidad de
multiresolución, estabilidad de la discretización y un nexo inherente entre
la simulación y la física representada~\cite{ppm}.

Un resultado teórico importante es la necesidad de reubicar periódicamente
las partículas sobre una malla regular para asegurar la convergencia.  Esto ha
dado origen a los métodos híbridos partícula-malla, que además de evitar la
distorsión de las partículas, permite integrar los métodos de partículas con
algoritmos eficientes diseñados sobre grillas~\cite[\S3]{multiscale}.

Otro aspecto importante en el que ha habido resultados importantes recientes es
en las simulaciones de partículas con varios niveles de resolución.  Se ha
propuesto esquemas que utilizan
partículas con tamaños variables,
mapeos adaptivos globales,
refinamientos adaptivos de malla
y análisis multiresolución usando wavelets~\cite{multiresolution}.

La escasez de bibliotecas científicas relevantes y la dificultad de paralelizar
eficientemente los métodos fueron problemas que impidieron la implementación
eficiente de estos métodos.  Recientemente el ETH de Zúrich desarrolló una
biblioteca paralela para métodos partícula-malla que facilita implementarlos
eficientemente sobre arquitecturas paralelas~\cite{ppm}.

También ha habido trabajos recientes con simulaciones de fluídos usando partículas
en GPUs, principalmente en el área de computación gráfica.  Los métodos usados
para visualización buscan conseguir realismo visual, y no resuelven con
exactitud las ecuaciones que discretizan.  Una implementación de un método de
vórtices publicada en julio de 2008 asegura ser la primera simulación de fluídos
exacta usando partículas en la GPU~\cite{vortex-gpu}.  Esta implementación está
descrita en función de directivas gráficas, mapeando las partículas a texturas,
en las que cada canal de color representa las propiedades de las partículas, y
expresando los pasos del algoritmo como shaders del pipeline gráfico.

%Un tipo importante de métodos de partículas son los métodos de vórtices (VM),
%que han sido utilizados desde la década de 1930 para describir la evolución de
%estructuras vorticales en fluídos incompresibles~\cite{multiscale}.
%En los últimos años se ha demostrado resultados importantes acerca de la
%convergencia y 

%Los VMs resuelven la ecuación de Navier-Stokes en su formulación
%velocidad-vorticidad:
%\begin{equation}
%    \frac{\partial\vort}{\partial t} + (\vel\cdot\nabla)\vort =
%    (\vort\cdot\nabla)\vel + \nu\Delta\vort,
%\end{equation}
%donde $\mathbf{u}$ es la velocidad
%y $\vort = \nabla\times\mathbf{u}$ es la vorticidad.  La velocidad se obtiene
%resolviendo la ecuación de Poisson: $\Delta\vel u = -\nabla\times\vort$


\subsection{Propuesta de tesis}
La tendencia en los entornos de programación de GPUs es a ofrecer interfaces
cada vez más genéricas, de modo de poder ser utilizadas para escribir programas
de propósito general.  Esto puede ser descrito como un acercamiento bottom-up
al desarrollo de software de alto desempeño:  partiendo del hardware gráfico,
se crean las abstracciones que serán utilizadas para crear programas.

Esta tesis intenta explorar un acercamiento top-down, enfocado a un dominio de
problema específico: cómo diseñar una biblioteca de alto nivel, en un lenguaje
de características dinámicas, cuyos componentes puedan correr en la GPU de
manera transparente al programador.  La idea es que las abstracciones provistas
por la interfaz estén en el dominio de los métodos de partículas.

Como producto final se espera presentar una pequeña biblioteca que sirva de
prueba de concepto para el desarrollo de aplicaciones aceleradas por GPU en un
dominio particular, evaluando el impacto en performance y complejidad de
programación de las decisiones de diseño tomadas.

Con el fin de acotar el número de factores involucrados, el trabajo de tesis se
enfocará en la implementación de métodos de vórtices en dos dimensiones.  Varios
tipos de componentes pueden ser integrados en un método de este tipo; por
ejemplo: diferentes condiciones de borde, diferentes modelos de difusión,
distintos modelos de multiresolución, y diferentes métodos para evaluar la
velocidad a partir de la vorticidad.



\newpage
\section{Hipótesis de Trabajo}

\emph{Formule las hipótesis de trabajo señalando claramente su conjetura.}
\emph{(Su extensión no debe exceder el espacio disponible) }

\section{Objetivos }

\subsection{Objetivos Generales}

\emph{(Su extensión no debe exceder el espacio disponible)}

\subsection{Objetivos Específicos}

\emph{(Su extensión no debe exceder el espacio disponible) }
       

\section{Metodología y Plan de Trabajo}

\emph{(Su extensión no debe exceder el espacio disponible)}

 
\section{Resultados}

\subsection{Aportes y Resultados Esperados}

\emph{(Su extensión no debe exceder el espacio disponible)}
 

\subsection{Formas de Validación}

\emph{(Su extensión no debe exceder el espacio disponible)}
 

\section{Recursos}

\subsection{Recursos disponibles}

\emph{Señale medios y recursos con que cuenta el Departamento de Informática de
la UTFSM, para realizar el proyecto de tesis (libros, software, laboratorios,
etc.).}

\emph{(Su extensión no debe exceder el espacio disponible) }

Los recursos de hardware y software del Laboratorio de Métodos Cuantitativos
serán suficientes para el desarrollo de este trabajo.

\subsection{Recursos solicitados}

\emph{Señale medios y recursos no disponibles en el Departamento de Informática
de la UTFSM, necesarios para realizar el proyecto de tesis (libros, software,
laboratorios, etc. ). Su extensión no debe exceder el espacio disponible}

No hay recursos por solicitar.



\begin{thebibliography}{99}
    \bibitem{gpu-computing}
    John D.~Owens et~al.
    \reftitle{GPU Computing.}
    Proceedings of the IEEE, May 2008.

    \bibitem{parallel-programming}
    Barru Wilkinson, Michael Allen.
    \reftitle{Parallel Programming.}

    \bibitem{hpc-gpu-cuda-slides}
    HPC GPU CUDA slides.

    \bibitem{gpupp}
    Thomas C.~Jansen.
    \reftitle{GPU++: An Embedded GPU Development System for
      General-Purpose Computations.}
    Tesis doctoral, Technischen Universität München, 2007.

    \bibitem{pygpu}
    Calle Lejdfors.
    \reftitle{High-level GPU programming: Domain-specifi optimization and inference.}
    Tesis doctoral, Lund University, 2008.

    \bibitem{multiresolution}
    Michael Bergdorf, Petros Koumoutsakos.
    \reftitle{Multiresolution Particle Methods}
    Complex Effects in Large Eddy Simulations, 56~(2006) 49--61.

    \bibitem{multiscale}
    Petros Koumoutsakos.
    \reftitle{Multiscale Flow Simulations Using Particles.}
    Annu.~Rev. Fluid~Mech. 37~(2005) 457--487.

    \bibitem{ppm}
    I.F.~Sbalzarini et~al.
    \reftitle{PPM -~A highly efficient parallel particle-mesh library
      for the simulation of continuum systems.}
    Journal of Computational Physics 215~(2006) 566--588.

    \bibitem{vortex-gpu}
    Diego Rossinelli, Petros Koumoutsakos.
    \reftitle{Vortex methods for incompressible flow simulations on the GPU.}
    Visual Comput~(2008).

    \bibitem{brookgpu}
    Ian Buck et~al.
    \reftitle{Brook for GPUs: Stream Computing on Graphics Hardware.}
    Stanford University.

    \bibitem{pycuda}
    Andreas Klöckner.
    PyCUDA.
    \url{http://mathema.tician.de/software/pycuda}


\end{thebibliography}





%\section*{Abstract}
%Stream computing is a parallel computing paradigm in which large streams of data
%flow through kernel functions, capable of performing non-trivial operations in
%parallel. Streaming architectures achieve high-troughput by exploiting
%algorithms that exhibit high arithmetic intensity.
%
%This paradigm is well-suited for computation on commodity graphic hardware.
%Current graphic processing units are agressively pipelined processors, and are
%capable to perform general-purpose floating-point computation with one order of
%magnitude better performance than CPUs. Vendor-provided APIs are moving from
%supporting only graphic-related operations towards more generic programming
%models.
%
%Still, GPUs still offer a very restricted programming model. Currently there is
%active development in order to integrate streaming low-level APIs into
%higher-level programming languages, including highly dynamic languages. Several
%different approaches have been implemented, allowing to exploit agressive
%parallelism, while keeping the advantages of high-level development.
%
%As opposed to these frameworks, that aim at providing a generic set of operations
%suitable for a wide class of algorithms, this work explores the design of
%high-level stream-computing operations specifically for implementing particle
%methods in fluid dynamics, tailored to tackle the performance bottlenecks of
%this kind of methods.
%
%Particle methods solve transport problems by advecting discrete particles that
%carry the transported quantities, in order to solve the governing equations in
%their Lagrangian form. As all computational fluid dynamics techniques, these
%methods require large computational power, and can enjoy significant speedups by
%exploiting parallelism.
%
%A top-down approach for this specific domain will be adopted, by decomposing
%high-level implementations into parts that are suitable for being parallelized,
%taking into account the perfomance tradeoffs implied with each decision.

\end{document}
% Observaciones y sugerencias
% 1. No esta claro por que hacer esto. Cuales son los beneficios que se esperan.
% 2. ¿Por que las otras propuestas no son adecuadas para el particle methods?
% 3. Me llama la atencion que se plantee una tesis de Doctorado para un prob-
%    lema particular. Que de interesante tiene este problema ?, ¿ es facil ex-
%    tender la solucion a otros problemas en otrosambitos?
% 4. Plantear claramente las hipotesis.
% 5. En la presentacion considerar referencias bibliograficas que avalen la prop-
%    uesta, es decir, que justifiquen la necesiddad (si es que existen).
