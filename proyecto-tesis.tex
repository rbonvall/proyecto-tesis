% vim: set fileencoding=utf-8 encoding=utf-8 textwidth=80:
\documentclass[11pt,spanish]{article}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{fullpage}
\usepackage{url}
\usepackage{mathptmx}
\usepackage[scaled=.9]{helvet}
\usepackage{amsmath}
\usepackage{array}
%\usepackage{mathrsfs}
%\usepackage{amssymb}
%\usepackage{amsbsy}

\newcommand{\reftitle}{\textit}
\newcommand{\vel}{\mathbf{u}}
\newcommand{\vort}{\mathbf{\omega}}
\newcommand{\pos}{\mathbf{x}}
\newcommand{\tnhl}{\tabularnewline\hline}
%\def\thesection{\Roman{section}}

\title{
    Departamento de Informática \\
    Universidad Técnica Federico Santa María \\
    \vspace{0.7em}\textbf{\huge Proyecto de Tesis} \\
    Magíster en Ciencias de la Ingeniería Informática}
\date{}
\author{}
\date{}

\begin{document}
\fontfamily{phv}
%\vspace{-2em}
\maketitle
\thispagestyle{empty}
\Large
\begin{center}
\begin{tabular}{|%
    r @{ } %
    >{\bfseries\raggedright\hspace{0pt}} p{0.3\textwidth} |%
    >{\raggedright\hspace{0pt}}          p{0.6\textwidth} <{} |%
}\hline
   1.& Título del proyecto de tesis & \emph{GPU-accelerated particle-based fluid simulations
                                      in a dynamic programming language}.\tnhl
   2.& Nombre del alumno            & Roberto Javier Bonvallet Carrasco\tnhl
   3.& Número de teléfono           & +56 32 2654423\tnhl
   4.& Correo electrónico           & rbonvall@inf.utfsm.cl\tnhl
   5.& Fecha de ingreso al programa & Primer semestre de 2006 \tnhl
   6.& Pregrado                     & Licenciatura en Ingeniería Informática, \\
                                      Universidad Técnica Federico Santa María, 2006\tnhl
   7.& Profesor guía de tesis       & Luis Salinas Carrasco\tnhl
%   8.& Fecha presentación tema de tesis & Martes 9 de diciembre de 2008\tnhl
   8.& Fecha presentación tema de tesis & \tnhl
   9.& Fecha aprobación tema de tesis   & \tnhl
  10.& Fecha tentativa de término       & Julio de 2009\tnhl
  11.& Comisión interna de graduación   & \tabularnewline&&\tabularnewline&& \tnhl
\end{tabular}
\end{center}
\normalsize

\newpage
\section*{Resumen}
%\emph{Debe ser suficientemente informativo, y contener una síntesis del proyecto, sus
%objetivos, resultados esperados y palabras claves. }

Las tarjetas gráficas (GPUs) han pasado a formar parte del repertorio de
arquitecturas de computación de alto desempeño (HPC), como consecuencia de su
rápida evolución en términos de poder de cómputo y programabilidad, y su bajo
costo.  Las GPUs son cada vez más utilizadas para acelerar aplicaciones
intensivas en cómputo en dominios no relacionados con la computación gráfica.
El modelo de programación de las GPUs está muy restringido por las limitaciones
del hardware, y requiere gran atención a detalles de bajo nivel por parte del
programador.  La integración de las GPUs en entornos de programación de alto
nivel, incluyendo lenguajes altamente dinámicos, es un área de investigación
activa.

Las aplicaciones HPC suelen ser desarrolladas en lenguajes compilados, que
optimizan el uso del hardware.  Los lenguajes interpretados sacrifican
performance por conveniencia de desarrollo, y no aprovechan el hardware
directamente, pero pueden ser extendidos mediante componentes binarios.  Esto
permite combinar la eficiencia de los lenguajes compilados con la flexibilidad
de los lenguajes dinámicos.

Una de las disciplinas que tradicionalmente ha exigido recursos de HPC es la
dinámica de fluidos computacional (CFD).  Las simulaciones de fluidos son
computacionalmente complejas, y tienen importantes aplicaciones industriales.
Los métodos de partículas (PMs), una clase de técnicas de CFD, discretizan el
dominio de un problema usando partículas que son arrastradas por el fluido, y
resuelven las ecuaciones subyacentes en su formulación lagrangiana, en 
contraste con la formulación euleriana en que se basa la mayoría de los métodos
tradicionales.

Los métodos de partículas no han sido muy utilizados en la práctica, debido a
dificultades numéricas y de implementación.  Sin embargo, trabajos recientes han
demostrado que gozan de importantes ventajas numéricas sobre otras clases de
métodos, y que pueden ser implementados eficientemente en arquitecturas
paralelas.

Este proyecto de tesis consiste en el desarrollo de un prototipo de biblioteca
para simulaciones de fluidos mediante métodos partículas, descritas usando
componentes de alto nivel en un entorno de programación dinámico, y acelerada
transparentemente en la GPUs mediante técnicas de metaprogramación.

\paragraph{Palabras claves:}
computación de alto desempeño,
%métodos de vórtices,
computación en GPUs,
dinámica de fluidos computacional,
métodos de partículas,
lenguajes de programación dinámicos.

\newpage
\section*{Abstract}
Graphic processing units (GPUs) have become a integral part
of the High Performance Computing architecture repertoire, as a consequence of
their rapid evolution in terms of computing power and programmability, and their
affordable cost.  GPUs are being increasingly used to accelerate non-graphic
applications.  The GPU programming model is very restricted by the limitations
of the hardware, and it forces the programmer to pay great attention to low-level
details.  The integration of GPUs to high-level programming environments,
including highly-dynamic languages, is an active area of research.

HPC applications are usually developed in compiled languages, that optimize the
use of hardware.  Interpreted languages sacrifice performance for development
convenience, and do not take direct advantage of the hardware, but can be
extended with binary components, enabling a compromise between the efficiency of
compiled code and the flexibility of dynamic languages.

One of the disciplines that traditionally has required HPC resources is
Computational Fluid Dynamics (CFD).
Fluid simulations are computationally complex, and have important industrial
applications.
Particle Methods (PMs), a CFD class of techniques, discretize the problem domain
by using particles that get convected along the fluid, and solve the underlying
equations in their Lagrangian formulation, as opposed to the Eulerian
formulation that most traditional methods are based on.

Particle Methods have not been widely used in practice, because of numerical and
implementation issues.  However, recent works have proven that they enjoy
important numerical advantages over other classes of methods, and that they can
be efficiently implemented in parallel architectures.

This thesis proposal consists in the development of a proof-of-concept
particle-based fluid simulation library, described by high-level components in a
dynamic programming environment, and transparently accelerated on the GPU by
using metaprogramming techniques.

\paragraph{Keywords:}
High Performance Computing,
%Vortex Methods,
General Purpose GPU Computing,
Computational Fluid Dynamics,
Particle Methods,
Dynamic Programming Languages.

\newpage
\section{Formulación general de la problemática y propuesta de tesis}

%\emph{Debe contener la exposición general del problema, identificando claramente qué
%aspectos relacionados con la informática son los más relevantes.  Además,
%deberá contener el marco teórico, la discusión bibliográfica con sus
%referencias y, finalmente, su propuesta de tesis.}
%
%\emph{(La extensión máxima de esta sección es de hasta 5 páginas.  En hojas
%adicionales incluya la lista de referencias)}

El trabajo de tesis propuesto consiste en el análisis, diseño e implementación
de componentes para hacer simulaciones de dinámica de fluidos mediante métodos
basados en partículas, utilizando la GPU como recurso computacional, y
ofreciendo una interfaz de alto nivel en un lenguaje de programación dinámico.

El problema general en que se enmarca este trabajo, y que es objeto de activa
investigación en la actualidad, es el aprovechamiento de arquitecturas paralelas
para acelerar aplicaciones con requerimientos exigentes de poder de cómputo, en
entornos de programación de alto nivel, abstrayendo los detalles del hardware.
Este problema es transversal a varias áreas de la informática: computación
científica, computación paralela, compiladores, lenguajes de programación e
ingeniería de software.

En particular, esta tesis se enfocará en la integración de GPUs con lenguajes de
programación de naturaleza dinámica, enfocándose en un dominio de problema
específico: los métodos de partículas.


\subsection{Computación de alto desempeño}

A lo largo de la historia de la computación, ha existido una demanda creciente de poder
computacional en las áreas de la ciencia y la ingeniería.  A medida que ha
aumentado la capacidad de cómputo disponible, también han crecido el tamaño y la
complejidad de los problemas que se necesita resolver, y en el caso de los
problemas más complejos, ni siquiera es posible hacerlo en un tiempo razonable.
\cite{parallel-programming}

La computación de alto desempeño~(HPC) estudia la utilización de supercomputadores y
clústers de computadores para resolver problemas computacionales complejos.  Los
conceptos claves en HPC son:
\begin{itemize}
   \item paralelismo:
     la capacidad de ejecutar instrucciones concurrentemente;
   \item escalabilidad:
     la capacidad de acomodarse a problemas de tamaño creciente;
   \item computación commodity:
     sistemas computacionales construídos con hardware
     estándar y de bajo costo, con componentes de software off-the-shelf
     (interoperabilidad).
\end{itemize}
La tendencia actual en sistemas de HPC y en diseño de arquitecturas de hardware
apunta a explotar el paralelismo para obtener mejoras en el desempeño final de un
programa, a pesar de la carga adicional que significa manejar la concurrencia
(preferir high throughput sobre high performance).
%\cite{hpc-gpu-cuda-slides}

\subsection{Computación en hardware gráfico}
Las unidades de procesamiento gráfico (GPU) son componentes de hardware diseñados
originalmente para acelerar aplicaciones de computación gráfica (CG), que son
intensivas en cómputo y requieren resultados en tiempo real.  Las
características de una aplicación gráfica que pueden ser efectivamente
paralelizadas, y que son explotadas por la GPU, son:
\begin{itemize}
  \item stream processing:
    las operaciones visuales suelen ser completamente independientes entre
    píxeles, y pueden ejecutarse concurrentemente;  las GPUs obtienen su mayor
    ganancia en desempeño destinando muchos procesadores
    separados para aplicar una operación sobre un gran arreglo de
    datos~\cite[\S3.2]{gpupp};
  \item pipelining:
    las diferentes etapas de un algoritmo gráfico (p.ej.
    transformaciones espaciales, aplicación de texturas, rasterización)
    forman una estructura de tubería (pipeline), en que la salida de una etapa
    sirve de entrada a la siguiente;  las GPUs implementan este pipeline en
    hardware, ofreciendo cierto grado de programabilidad sobre sus
    etapas~\cite[\S3.1]{pygpu};
  \item vector processing:
    casi todas las cantidades involucradas en computación
    gráfica son vectores (colores, puntos, segmentos, direccionamiento en
    texturas); por ello, las instrucciones de la GPU operan sobre 4-vectores de
    números de coma flotante, en lugar de sobre cantidades escalares.
    \cite[\S3.3]{gpupp}
\end{itemize}

En la última década, las GPUs han evolucionado rápidamente en términos de
capacidad computacional y de programabilidad.  Su capacidad de cómputo ya supera
por un orden de magnitud la de las CPUs~\cite{gpupp}.  Este poder computacional ha
incentivado el uso de GPUs para computación de propósito general, al punto que
ya han pasado a ser parte integral del repertorio de aplicaciones
HPC~\cite{gpu-computing}.
Un hito importante en esta tendencia fue la aparición, en noviembre de 2008, del
primer clúster basado en GPUs en la lista Top500, un ránking semestral de los
500 supercomputadores más poderosos del mundo~\cite{top500}.

A medida que las GPUs se hacían más programables, también evolucionaron las
interfaces para programación.  Inicialmente, los procesadores de
vértices y de fragmentos debían ser programados a nivel de lenguaje de
ensamblado.
Después aparecieron lenguajes de más alto nivel como Cg, HLSL y GLslang,
que sin embargo aún utilizaban llamadas explícitas a las APIs gráficas.
Debido a esto, la implementación de algoritmos de propósito general
requería expresarlos en función de directivas gráficas~\cite[\S2.2]{brookgpu}.
Programar la GPU implicaba crear shaders ---programas que pintan píxeles a partir
de los vértices---, fragmentos y texturas que le sirven de entrada.

Las abstracciones gráficas (vértices, fragmentos, texturas, shaders)
son análogas a un paradigma más general denominado \emph{stream processing},
en que una serie de operaciones de cómputo (los kernels) son aplicados sobre
cada elemento de un conjunto de datos de entrada (el stream).  Este modelo es
incorporado en lenguajes para GPUs más recientes como Brook y CUDA.

A pesar de ofrecer modelos de programación cada vez más flexibles,
las GPUs siguen siendo un entorno de programación extremadamente limitado,
y no cualquier algoritmo es apropiado para ser acelerado en la GPU.
En particular, la programación usando streams
incentiva aplicaciones con alta intensidad aritmética
(tasa de operaciones por ancho de banda de memoria)~\cite[\S2.1]{brookgpu}.
Operaciones que son elementales en la CPU, como
ejecución condicional y acceso directo a memoria, no permiten explotar el
paralelismo y el ancho de banda de la GPU, e introducen penalizaciones de
rendimiento importantísimas~\cite[\S{}V.C]{gpu-computing}.

\subsection{Programación científica de alto nivel y las GPUs}
La programación de aplicaciones de ciencia e ingeniería se caracteriza por sus
exigentes requerimientos de performance.  Las bibliotecas científicas suelen
estar implementadas en lenguajes compilados, típicamente C y Fortran, cuyos
compiladores realizan optimizaciones agresivas que permiten obtener binarios
extremadamente eficientes en términos de tiempo de ejecución, aprovechando al
máximo la arquitectura del computador.

Por otra parte, existen los lenguajes de programación dinámicos (p.ej.~Lisp,
Python, Ruby, Scheme) que están diseñados para aumentar la eficiencia
del programador.  Permiten ciclos de desarrollo más rápido, presentan
abstracciones más cercanas al problema que a la máquina, y ofrecen
facilidades de metaprogramación~\cite[\S2]{pygpu}.  Como consecuencia, los
programas suelen ser más fáciles de implementar, de mantener y de reutilizar,
y se adaptan mejor al esquema de trabajo de un programador científico,
típicamente orientado a refinar prototipos en varias iteraciones.

El precio del dinamismo es una altísima penalización en rendimiento.  Por esto,
los entornos de programación científicos dinámicos están diseñados para servir
de pegamento entre bibliotecas binarias altamente optimizadas.  Este esquema es
utilizado exitosamente, por ejemplo, por el lenguaje Matlab y por la biblioteca
Numpy en el lenguaje Python, lo que permite desarrollar aplicaciones científicas
completas de rendimiento aceptable sin necesidad de escribir código en un
lenguaje compilado.

Muy recientemente han aparecido sistemas para integrar la programación de GPUs
de manera transparente en lenguajes de alto nivel.

GPU++~\cite{gpupp} (2007) es un sistema de desarrollo integrado con C++ que
permite implementar y utilizar kernels abstrayendo tanto la GPU como la CPU.
Introduce varias técnicas de optimización, y administra en lugar del programador
la ejecución de código y el copiado de datos entre el procesador y la tarjeta
gráfica.

PyGPU~\cite{pygpu} (2008) es una biblioteca para escribir funciones para la
GPU en Python. Utiliza las capacidades introspectivas del lenguaje,
introduciendo un decorador que examina el bytecode de la función y anotaciones
adicionales, y compila el código para la GPU.

PyCUDA~\cite{pycuda} (2008) es una biblioteca que permite acceder directamente a
la API de CUDA desde Python, ofreciendo además varias conveniencias adicionales,
como una estructura de datos para representar matrices y vectores, cuyas
operaciones son ejecutadas transparentemente en la GPU.

Además, entornos comerciales de programación científica como Mathematica y
Matlab también han comenzado a ofrecer integración transparente con GPUs~%
\cite{nvidia-mathematica}~\cite{nvidia-matlab}.


\subsection{Dinámica de fluidos computacional}
Una de las áreas de investigación que tradicionalmente ha tenido requerimientos
exigentes de poder de cómputo para sus simulaciones es la dinámica de fluidos.
La dinámica de fluidos computacional tiene importantes aplicaciones industriales
en diversas áreas como la aeronáutica, la meteorología y la geología.

La dinámica de fluidos estudia los fluidos en movimiento.  Los problemas de la
dinámica de fluidos consisten en calcular varias propiedades del fluido (p.ej.
la velocidad $\vel$, la presión $p$, la densidad $\rho$, la temperatura $T$) en
todo el dominio del fluido, durante un intervalo de tiempo.  Estas propiedades
se llaman variables de estado, y están relacionadas por leyes de conservación y
ecuaciones de estado, que están expresadas como ecuaciones diferenciales parciales.

En general los problemas de dinámica de fluidos no se pueden resolver
analíticamente excepto en casos triviales.  La dinámica de fluidos computacional
(CFD) usa métodos numéricos para resolver estos problemas, que aun así siguen
siendo complejos:  incluso con ecuaciones simplificadas y usando recursos de
HPC, sólo es posible obtener soluciones aproximadas.

La ecuación más importante de la dinámica de fluidos es la ecuación de
Navier-Stokes, que describe la conservación de momentum en un fluido viscoso,
de manera análoga a la segunda ley de Newton:
\begin{equation}
    \rho\left(\frac{\partial\vel}{\partial t} + \vel\cdot\nabla\vel \right) =
    \text{fuerzas por unidad de volumen}.
    %\nu\Delta\vel - \nabla p + \mathbf{f}.
\end{equation}
El término $\rho(\vel\cdot\nabla\vel)$ es denominado aceleración convectiva, y
explica cómo cambia la velocidad con respecto a la posición en un instante de
tiempo fijo.  Éste es el único término no lineal de la ecuación, lo que acarrea
problemas numéricos al discretizar el problema, y en la práctica representa el
principal aporte a la turbulencia del fluido.

La turbulencia es el comportamiento caótico observado en los fluidos.  Es un
fenómeno cuya naturaleza no está bien comprendida, y es difícil de cuantificar y
de describir.  Los métodos numéricos para fluidos turbulentos deben incorporar
algún tipo de modelo de turbulencia, generalmente con base experimental, para
dar cuenta de ella.  Además, la turbulencia emerge en varios niveles de escala,
lo que exige alta resolución en la discretización de los problemas, y por lo
tanto más poder computacional.

\subsection{Métodos de partículas}
La mayoría de los métodos de CFD discretizan el dominio del problema utilizando
algún tipo de malla.  Los métodos de partículas, en cambio, son una clase
de métodos que utilizan partículas discretas que arrastran distribuciones
localizadas de variables de estado por el fluido.  Las propiedades físicas del
fluido pueden ser recuperadas como una superposición de las distribuciones
de todas las partículas.

Las métodos de partículas están basados en la formulación en coordenadas
lagrangianas de las ecuaciones subyacentes.  La forma lagrangiana utiliza como
marco de referencia las trayectorias de las partículas en el tiempo, y en ella
no aparece el término de aceleración convectiva.  Las ecuaciones pasan a ser un
sistema de ecuaciones diferenciales ordinarias:
\begin{align}
    \frac{d\pos_p}{dt} &= \vel_p(\pos_p, t) =
        \sum_{p'} \mathbf{K}(\pos_p, \pos_{p'}; \xi_p, \xi_{p'}), &
    \frac{d\xi_p}{dt} &=
        \sum_{p'} \mathbf{F}(\pos_p, \pos_{p'}; \xi_p, \xi_{p'});
\end{align}
donde $\xi$ es alguna propiedad del fluido, y $\mathbf{K}$ y $\mathbf{F}$
representan la dinámica del sistema físico simulado.

Una clase importante de métodos de partículas son los métodos de vórtices (VM),
que han sido utilizados desde la década de 1930 para describir la evolución de
estructuras vorticales en flujos incompresibles~\cite[\S2.2]{multiscale}.  Los
VMs describen la evolución de la vorticidad $\vort = \nabla\times\vel$ del
fluido.  En cada iteración, es necesario recuperar la velocidad a partir de la
vorticidad para avanzar las partículas, y este paso es el más costoso en
términos computacionales.  Por otra parte, en muchos fluidos la vorticidad es
no nula sólo en una región reducida del dominio, lo que permite reducir el
número de partículas necesarias para la simulación.

Los métodos de vórtices han sido utilizados en aplicaciones de ingeniería,
sus resultados tienen buena concordancia con los experimentos, y se ha postulado
que su utilización introduce un modelo de turbulencia implícito.

Los métodos de partículas no fueron muy utilizados en la simulación de sistemas
continuos debido a dificultades numéricas y de implementación.  Trabajos
teóricos recientes han abordado exitosamente los problemas numéricos, y han
demostrado las ventajas de estos métodos:  adaptividad, capacidad de
multiresolución, estabilidad de la discretización y un nexo inherente entre
la simulación y el fenómeno físico subyacente~\cite{ppm}.

Un resultado teórico importante es la necesidad de reubicar periódicamente
las partículas sobre una malla regular para asegurar la convergencia.  Esto ha
dado origen a los métodos híbridos partícula-malla, que además de evitar la
distorsión de las partículas, permite integrar los métodos de partículas con
algoritmos eficientes diseñados sobre grillas~\cite[\S3]{multiscale}.

Otro aspecto importante en el que ha habido resultados importantes recientes es
en las simulaciones de partículas con varios niveles de resolución.
Se ha propuesto esquemas que utilizan
partículas con tamaños variables,
mapeos adaptivos globales,
refinamientos adaptivos de malla
y análisis multiresolución usando wavelets~\cite{multiresolution}.

Todas estas características adicionales, que apuntan a lograr un balance
conveniente entre exactitud de la solución y tiempo de cómputo, complementan el
framework genérico para describir los métodos de partículas.  En general, cada
iteración de una simulación tiene algunas etapas fijas, que están relacionadas
con diferentes aspectos del fluido: la convección, la difusión, la satisfacción
de las condiciones de borde, la adaptación espacial, y (para los métodos de
vórtices) la evaluación de la velocidad.  Para cada una de estas etapas, existen
varios modelos que pueden ser usados:  por ejemplo, para la convección, se puede
utilizar cualquier esquema de integración numérica de EDOs;  para la difusión,
se ha propuesto por lo menos siete esquemas diferentes~\cite[\S1.2]{barba}.

Hasta hace un par de años, la escasez de bibliotecas científicas relevantes y la
dificultad de paralelizar eficientemente estos métodos fueron problemas que
impidieron su implementación eficiente.  Recientemente, el ETH de Zúrich desarrolló una
biblioteca paralela para métodos partícula-malla que facilita implementarlos
eficientemente sobre arquitecturas paralelas de gran escala~\cite{ppm}.

También ha habido trabajos recientes con simulaciones de fluidos usando partículas
en GPUs, principalmente en el área de computación gráfica.  Los métodos usados
para visualización sólo buscan conseguir realismo visual, y no resuelven con
exactitud las ecuaciones que discretizan.  Una implementación de un método de
vórtices publicada en julio de 2008 asegura ser la primera simulación de fluidos
exacta usando partículas en la GPU~\cite{vortex-gpu}.  Esta implementación está
descrita en función de directivas gráficas, mapeando las partículas a texturas,
en las que cada canal de color representa las propiedades de las partículas, y
expresando los pasos del algoritmo como shaders del pipeline gráfico.

%Los VMs resuelven la ecuación de Navier-Stokes en su formulación
%velocidad-vorticidad:
%\begin{equation}
%    \frac{\partial\vort}{\partial t} + (\vel\cdot\nabla)\vort =
%    (\vort\cdot\nabla)\vel + \nu\Delta\vort,
%\end{equation}
%donde $\mathbf{u}$ es la velocidad
%y $\vort = \nabla\times\mathbf{u}$ es la vorticidad.  La velocidad se obtiene
%resolviendo la ecuación de Poisson: $\Delta\vel u = -\nabla\times\vort$


\subsection{Propuesta de tesis}
Este proyecto de tesis consiste en el análisis, diseño e implementación de un
prototipo de una biblioteca para hacer simulaciones de fluidos con las
siguientes características:
\begin{itemize}
    \item el modelo utilizado será el framework genérico de métodos de
       partículas propuesto y descrito por Koumoutsakos~\cite{multiscale};
    \item los componentes de la simulación serán implementados en un lenguaje de
        programación dinámico de alto nivel;
    \item la simulación será acelerada transparentemente en hardware gráfico.
\end{itemize}
El propósito del proyecto es servir de prueba de concepto para el
desarrollo de bibliotecas de propósito específico, en lenguajes de alto nivel,
que puedan explotar eficiente y transparentemente el hardware paralelo disponible.

%Los objetivos del proyecto,  son obtener tiempos de ejecución mejores que los que se
%pueden lograr usando sólo la CPU,

%La metodología propusta

El modelo de ejecución de la GPU no incentiva el desarrollo de componentes
totalmente desacoplados.  Como la compilación de los kernels se realiza en tiempo
de ejecución, y cargar los streams de datos es muy costoso, conviene
que toda la simulación sea cargada en la GPU de manera unificada.  Para
implementar eficientemente componentes desacoplados e intercambiables,
la simulación no debe ser descrita algorítmicamente, sino declarativamente.  En
lenguajes de alto nivel, es posible combinar ambos enfoques usando mecanismos de
metaprogramación e introspección.  La factibilidad de utilizar estas técnicas
está sustentada en bibliotecas que hacen uso de ellas, como OpenFOAM~(en C++,
para simulaciones de fluidos)~\cite{openfoam} y PyGPU~(en Python, para
procesamiento de imágenes)~\cite{pygpu}.

La factibilidad de implementar eficientemente métodos de partículas en hardware
gráfico está sustentada por el trabajo de Rossinelli y Koumoutsakos, que
describe un método de vórtices exacto y eficiente implementado en una
GPU~\cite{vortex-gpu}.

La factibilidad de integrar transparentemente la GPU con lenguajes de
programación de propósito general a través de abstracciones de alto nivel está
sustentada en varios desarrollos recientes, como los mencionados
GPU++~\cite{gpupp}, PyGPU~\cite{pygpu} y PyCUDA~\cite{pycuda}.

El énfasis del proyecto estará puesto en el aspecto computacional de las
simulaciones y no en la convergencia de los métodos implementados.  Trabajos
recientes han abordado las propiedades numéricas de los métodos de partículas, y
de sus componentes.  Una vez finalizada la tesis, la biblioteca desarrollada
debería servir como herramienta de experimentación para explorar la
incorporación de nuevos componentes a estos métodos.

\newpage
\begin{thebibliography}{99}
    \bibitem{gpu-computing}
    John D.~Owens et~al.
    \reftitle{GPU Computing.}
    Proceedings of the IEEE, May 2008, 879--899.

    \bibitem{multiresolution}
    Michael Bergdorf, Petros Koumoutsakos.
    \reftitle{Multiresolution Particle Methods.}
    Complex Effects in Large Eddy Simulations, 56~(2006) 49--61.

    \bibitem{multiscale}
    Petros Koumoutsakos.
    \reftitle{Multiscale Flow Simulations Using Particles.}
    Annu.~Rev. Fluid~Mech. 37~(2005) 457--487.

    \bibitem{ppm}
    I.F.~Sbalzarini et~al.
    \reftitle{PPM -~A highly efficient parallel particle-mesh library
      for the simulation of continuum systems.}
    Journal of Computational Physics 215~(2006) 566--588.

    \bibitem{vortex-gpu}
    Diego Rossinelli, Petros Koumoutsakos.
    \reftitle{Vortex methods for incompressible flow simulations on the GPU.}
    Visual Comput~(2008).

    \bibitem{barba}
    Lorena Barba.
    \reftitle{Vortex Method for computing high-Reynolds number flows:
    Increased accuracy with a fully mesh-less formulation.}
    Tesis doctoral, California Institute of Technology, 2004.

    \bibitem{gpupp}
    Thomas C.~Jansen.
    \reftitle{GPU++: An Embedded GPU Development System for
      General-Purpose Computations.}
    Tesis doctoral, Technischen Universität München, 2007.

    \bibitem{pygpu}
    Calle Lejdfors.
    \reftitle{High-level GPU programming: Domain-specific optimization and inference.}
    Tesis doctoral, Lund University, 2008.

    \bibitem{brookgpu}
    Ian Buck et~al.
    \reftitle{Brook for GPUs: Stream Computing on Graphics Hardware.}
    Stanford University.

    \bibitem{parallel-programming}
    Barry Wilkinson, Michael Allen.
    \reftitle{Parallel Programming.}
    Pearson Prentice Hall, 2nd Edition, 2005.

    \bibitem{nvidia-mathematica}
    Nvidia Press Release.
    \reftitle{Mathematica Users Get 100x Performance Boost From NVIDIA CUDA.}
    \url{http://www.nvidia.com/object/io_1227010734073.html}

    \bibitem{nvidia-matlab}
    Nvidia Developer Zone.
    \reftitle{MATLAB plug-in for CUDA.}
    \url{http://developer.nvidia.com/object/matlab_cuda.html}

    \bibitem{top500}
    \reftitle{Top500 Supercomputing Sites.}
    \url{http://www.top500.org}

    \bibitem{openfoam}
    OpenCFD Ltd.
    \reftitle{OpenFOAM, The Open Source CFD Toolbox.}
    \url{http://www.opencfd.co.uk/openfoam/}

    \bibitem{pycuda}
    Andreas Klöckner.
    \reftitle{PyCUDA.}
    \url{http://mathema.tician.de/software/pycuda}

%    \bibitem{hpc-gpu-cuda-slides}
%    HPC GPU CUDA slides.

\end{thebibliography}

\newpage
\section{Hipótesis de trabajo}
Las hipótesis que sustentan este proyecto son las siguientes.
\begin{enumerate}
    \item Usando la GPU, es posible acelerar el rendimiento computacional de los
        métodos de partículas.
    \item Es posible describir las simulaciones de fluidos en un lenguaje de
        alto nivel de manera genérica y descriptiva, abstrayendo los detalles de
        implementación.
    \item Mediante técnicas de metaprogramación, es posible ejecutar las
        simulaciones de fluidos en la GPU de manera transparente.
\end{enumerate}

%\newpage
\section{Objetivos }

\subsection{Objetivos generales}
\begin{enumerate}
    \item Explorar la posibilidad de desarrollar bibliotecas de software de
        propósito específico que aprovechen arquitecturas de hardware paralelas
        de manera transparente.
    \item Estudiar el uso de una arquitectura de hardware paralela novedosa y de
        costo accesible para acelerar aplicaciones intensivas en cómputo.
    \item Evaluar mecanismos de comunicación entre un lenguaje de programación
        dinámico y el hardware gráfico, en términos de rendimiento computacional y
        complejidad para el desarrollador.
\end{enumerate}

\subsection{Objetivos específicos}
\begin{enumerate}
   \item Diseñar e implementar un prototipo de biblioteca
       para simulaciones de fluidos mediante métodos de partículas,
       en un lenguaje de programación dinámico,
       basada en componentes intercambiables,
       y acelerada en hardware gráfico de manera transparente.
   \item Correr simulaciones de fluidos con tiempos de ejecución comparables a los
       obtenidos usando el hardware gráfico directamente.
   \item Correr simulaciones de fluidos con tiempos de ejecución
       significativamente menores
       a los obtenidos usando un procesador común.
   \item Describir simulaciones de fluidos mediante componentes que permitan
       correr simulaciones con una complejidad de desarrollo sustancialmente
       menor que la enfrentada al programar los métodos directamente.
\end{enumerate}

\newpage
\section{Metodología y plan de trabajo}
El desarrollo del proyecto se llevará a cabo en las siguientes etapas:
\begin{enumerate}
    \item \textbf{Estado del arte:}
        estudio del marco teórico de métodos de partículas, tecnologías de
        programación de GPUs e integración con entornos de desarrollo dinámicos.
    \item \textbf{Prototipo de métodos de partículas en GPUs:}
        implementación de un prototipo funcional de un método de partículas en
        la GPU, como parte del estudio de la programación en GPUs, usando como
        base trabajos existentes en la literatura.
    \item \textbf{Prototipo de integración de GPU con el intérprete del lenguaje:}
        evaluación e implementación de distintos métodos de integración del
        hardware con el intérprete presentados en la literatura y en bibliotecas
        de código abierto.
    \item \textbf{Análisis y diseño de la biblioteca:}
        definición de los requerimientos, los algoritmos a usar, el modelo de
        ejecución, las técnicas de metaprogramación, la interfaz y los
        componentes de la biblioteca.
    \item \textbf{Definición de experimentos, métricas de evaluación y problemas de prueba:}
        recolección de benchmarks estándares de fluidos para evaluar convergencia y
        tiempo de ejecución, junto con métricas para evaluar rendimiento computacional y
        complejidad de desarrollo, y diseño de los experimentos a ejecutar.
    \item \textbf{Implementación de la biblioteca.}
    \item \textbf{Ejecución de experimentos y recolección de resultados.}
    \item \textbf{Publicación y presentación de la tesis.}
\end{enumerate}

El plan de trabajo propuesto es el siguiente:

\begin{tabular}{|%
    >{\raggedright\hspace{0pt}} p{0.55\textwidth} |%
    >{\raggedright\hspace{0pt}} p{0.3\textwidth} |%
}\hline
    \textbf{Actividad} & \textbf{Plazo}\tnhl
    Estado del arte           & 1 de febrero de 2009 \tnhl
    Prototipo de PMs en GPU   & 1 de marzo de 2009 \tnhl
    Prototipo de integración
    GPU-intérprete            & 1 de marzo de 2009 \tnhl
    Análisis y diseño         & 1 de abril de 2009 \tnhl
    Definición de experimentos, evaluación
    y pruebas                 & 1 de mayo de 2009 \tnhl
    Implementación            & 1 de junio de 2009 \tnhl
    Experimentos y resultados & 1 de julio de 2009 \tnhl
    Presentación tesis        & 31 de julio de 2009 \tnhl
\end{tabular}


 \newpage
\section{Resultados}

\subsection{Aportes y resultados esperados}
Los aportes y resultados que se busca obtener a través de este proyecto son los
siguientes:
\begin{enumerate}
    \item Una implementación de prueba de concepto de la biblioteca descrita.
    \item Una metodología para implementar bibliotecas de propósito específico
        aceleradas en la GPU en lenguajes de alto nivel.
    \item Evidencia experimental de que es posible acelerar simulaciones de
        fluidos en la GPU eficientemente.
    \item Publicación de artículos en journals, workshops o
        conferencias internacionales
        relacionados con
        computación de alto desempeño,
        dinámica de fluidos computacional y
        lenguajes de programación.
\end{enumerate}

\subsection{Formas de validación}
Los dos aspectos principales que se desea evaluar en este proyecto son el
rendimiento computacional y la complejidad de desarrollo.

El rendimiento computacional se evaluará en terminos de tiempo de cómputo, y
como parámetro de comparación se desarrollará prototipos funcionales sencillos
con características que sirvan como referencia para la evaluación.

Para evaluar la complejidad de desarrollo, se propondrá métricas sencillas
utilizadas comúnmente en ingeniería de software; por ejemplo: cantidad de líneas de código,
complejidad ciclomática y estimación de costos basada en Cocomo.

Para las simulaciones se utilizará problemas estándares de fluidos usados
tradicionalmente en la literatura para hacer pruebas.  Generalmente, se utiliza
fluidos cuya solución analítica es conocida, o que presentan características que
permiten reconocer si la convergencia ha sido adecuada.

\section{Recursos}

\subsection{Recursos disponibles}

%\emph{Señale medios y recursos con que cuenta el Departamento de Informática de
%la UTFSM, para realizar el proyecto de tesis (libros, software, laboratorios,
%etc.).}

Los recursos del Laboratorio de Métodos Cuantitativos
están a disposición para el desarrollo de esta tesis.
El Laboratorio adquirirá prontamente las GPUs que serán utilizadas por
este trabajo.

\subsection{Recursos solicitados}

%\emph{Señale medios y recursos no disponibles en el Departamento de Informática
%de la UTFSM, necesarios para realizar el proyecto de tesis (libros, software,
%laboratorios, etc. ). Su extensión no debe exceder el espacio disponible}

No hay recursos por solicitar.








%\section*{Abstract}
%Stream computing is a parallel computing paradigm in which large streams of data
%flow through kernel functions, capable of performing non-trivial operations in
%parallel. Streaming architectures achieve high-troughput by exploiting
%algorithms that exhibit high arithmetic intensity.
%
%This paradigm is well-suited for computation on commodity graphic hardware.
%Current graphic processing units are agressively pipelined processors, and are
%capable to perform general-purpose floating-point computation with one order of
%magnitude better performance than CPUs. Vendor-provided APIs are moving from
%supporting only graphic-related operations towards more generic programming
%models.
%
%Still, GPUs still offer a very restricted programming model. Currently there is
%active development in order to integrate streaming low-level APIs into
%higher-level programming languages, including highly dynamic languages. Several
%different approaches have been implemented, allowing to exploit agressive
%parallelism, while keeping the advantages of high-level development.
%
%As opposed to these frameworks, that aim at providing a generic set of operations
%suitable for a wide class of algorithms, this work explores the design of
%high-level stream-computing operations specifically for implementing particle
%methods in fluid dynamics, tailored to tackle the performance bottlenecks of
%this kind of methods.
%
%Particle methods solve transport problems by advecting discrete particles that
%carry the transported quantities, in order to solve the governing equations in
%their Lagrangian form. As all computational fluid dynamics techniques, these
%methods require large computational power, and can enjoy significant speedups by
%exploiting parallelism.
%
%A top-down approach for this specific domain will be adopted, by decomposing
%high-level implementations into parts that are suitable for being parallelized,
%taking into account the perfomance tradeoffs implied with each decision.

\end{document}
% Observaciones y sugerencias
% 1. No esta claro por que hacer esto. Cuales son los beneficios que se esperan.
% 2. ¿Por que las otras propuestas no son adecuadas para el particle methods?
% 3. Me llama la atencion que se plantee una tesis de Doctorado para un prob-
%    lema particular. Que de interesante tiene este problema ?, ¿ es facil ex-
%    tender la solucion a otros problemas en otrosambitos?
% 4. Plantear claramente las hipotesis.
% 5. En la presentacion considerar referencias bibliograficas que avalen la prop-
%    uesta, es decir, que justifiquen la necesiddad (si es que existen).
