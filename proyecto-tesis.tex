% vim: set fileencoding=utf-8 encoding=utf-8 textwidth=80:
\documentclass[11pt,spanish]{article}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{fullpage}
\usepackage{url}
\usepackage{mathptmx}
\usepackage{amsmath} 
\usepackage{array}
%\usepackage{mathrsfs} 
%\usepackage{amssymb} 
%\usepackage{amsbsy} 

\newcommand{\reftitle}{\textit}
\newcommand{\vel}{\mathbf{u}}
\newcommand{\vort}{\mathbf{\omega}}
\newcommand{\pos}{\mathbf{x}}
\newcommand{\tnhl}{\tabularnewline\hline}

\title{Proyecto de Tesis \\
    Magíster en Ciencias de la Ingeniería Informática \\
    \textsc{Borrador \#2}
}
\date{}
\author{Roberto Bonvallet}
\date{Noviembre de 2008}

\begin{document}
%\fontfamily{phv} % Helvetica
\maketitle
\thispagestyle{empty}
\Large
\begin{center}
\begin{tabular}{|%
    r <{.} @{ } %
    >{\bfseries\raggedright\hspace{0pt}} p{0.27\textwidth} |%
    >{\raggedright\hspace{0pt}}          p{0.5\textwidth} <{} |%
}\hline
   1 & Título del proyecto de tesis & \emph{GPU-accelerated particle-based fluid simulations
                                      in a dynamic programming language}.\tnhl
   2 & Nombre del alumno            & Roberto Javier Bonvallet Carrasco\tnhl
   3 & Número de teléfono           & no tiene\tnhl
   4 & Correo electrónico           & \texttt{rbonvall@inf.utfsm.cl}\tnhl
   5 & Fecha de ingreso al programa & Primer semestre de 2006 \tnhl
   6 & Pregrado                     & Licenciatura en Ingeniería Informática, UTFSM, 2006\tnhl
   7 & Profesor guía de tesis       & Luis Salinas Carrasco\tnhl
   8 & Fecha presentación tema de tesis & Martes 9 de diciembre de 2008\tnhl
   9 & Fecha aprobación tema de tesis   & \tnhl
  10 & Fecha tentativa de término       & Julio de 2009\tnhl
  11 & Comisión interna de graduación   & profe$_1$, \\ profe$_2$, \\ profe$_3$.\tnhl
\end{tabular}
\end{center}
\normalsize

\newpage
\section*{Resumen}

\emph{Debe ser suficientemente informativo, y contener una síntesis del proyecto, sus
objetivos, resultados esperados y palabras claves. }

\paragraph{Palabras claves:}
computación de alto desempeño,
dinámica de fluídos computacional,
métodos de partículas,
métodos de vórtices,
computación en GPUs,
lenguajes de programación dinámicos.


\newpage
\section*{Abstract}

\emph{Lo mismo, en inglés}

\paragraph{Keywords:}
High Performance Computing,
Computational Fluid Dynamics,
Particle Methods,
Vortex Methods,
General Purpose GPU Programming,
Dynamic Programming Languages.

\newpage
\section{Formulación General de la Problemática y Propuesta de Tesis}

%\emph{Debe contener la exposición general del problema, identificando claramente qué
%aspectos relacionados con la informática son los más relevantes.  Además,
%deberá contener el marco teórico, la discusión bibliográfica con sus
%referencias y, finalmente, su propuesta de tesis.}
%    
%\emph{(La extensión máxima de esta sección es de hasta 5 páginas.  En hojas
%adicionales incluya la lista de referencias)}

El trabajo de tesis propuesto consiste en el análisis, diseño e implementación
de componentes para hacer simulaciones de dinámica de fluídos basadas en partículas,
utilizando la GPU como recurso computacional, y ofreciendo una interfaz de alto
nivel en un lenguaje de programación dinámico.

\subsection{Computación de alto desempeño}

A lo largo de la historia de la computación, ha existido una demanda creciente de poder
computacional en las áreas de la ciencia y la ingeniería.  A medida que ha
aumentado la capacidad de cómputo disponible, también han crecido el tamaño y la
complejidad de los problemas que se necesita resolver, y en el caso de los
problemas más complejos, no es posible hacerlo en un tiempo razonable.
\cite{parallel-programming}

La computación de alto desempeño~(HPC) es la utilización de supercomputadores y
clústers de computadores para resolver problemas computacionales complejos.  Los
conceptos claves en HPC son:
\begin{itemize}
   \item paralelismo:
     la capacidad de ejecutar instrucciones concurrentemente;
   \item escalabilidad:
     la capacidad de acomodarse a problemas de tamaño creciente;
   \item computación commodity:
     sistemas computacionales construídos con hardware
     estándar y de bajo costo, con componentes de software off-the-shelf
     (interoperabilidad).
\end{itemize}
La tendencia actual en sistemas de HPC y en diseño de arquitecturas de hardware
ya no apunta a mejorar el rendimiento de las unidades de cómputo por separado,
sino a explotar el paralelismo para obtener mejoras en el desempeño final de un
programa, a pesar de la carga adicional que significa manejar la concurrencia.
(preferir high throughput sobre high performance)
\cite{hpc-gpu-cuda-slides}

\subsection{Computación en hardware gráfico}
Las unidades de procesamiento gráfico (GPU) son componentes de hardware diseñados
originalmente para acelerar aplicaciones de computación gráfica (CG), que son
intensivas en cómputo y requieren resultados en tiempo real.  Las
características de una aplicación gráfica que pueden ser efectivamente
paralelizadas, y que son explotadas por la GPU, son:
\begin{itemize}
  \item stream processing:
    las operaciones visuales suelen ser completamente independientes entre
    píxeles, y pueden ejecutarse concurrentemente;  las GPUs obtienen su mayor
    ganancia en desempeño destinando muchos procesadores
    separados para aplicar una operación sobre un gran arreglo de
    datos~\cite[\S3.2]{gpupp};
  \item pipelining:
    las diferentes etapas de un algoritmo gráfico (p.ej.
    transformaciones espaciales, aplicación de texturas, rasterización)
    forman una estructura de tubería (pipeline), en que la salida de una etapa
    sirve de entrada a la siguiente;  las GPUs implementan este pipeline en
    hardware, ofreciendo cierto grado de programabilidad sobre sus
    etapas~\cite[\S3.1]{pygpu};
  \item vector processing:
    casi todas las cantidades involucradas en computación
    gráfica son vectores (colores, puntos, segmentos, direccionamiento en
    texturas); por ello, las instrucciones de la GPU operan sobre 4-vectores de
    números de coma flotante, en lugar de sobre cantidades escalares.
    \cite[\S3.3]{gpupp}
\end{itemize}

En la última década, las GPUs han evolucionado rápidamente en términos de
capacidad computacional y de programabilidad.  Su capacidad de cómputo ya supera
por un orden de magnitud la de las CPUs~\cite{gpupp}.  Este poder computacional ha
incentivado el uso de GPUs para computación de propósito general, al punto que
ya han pasado a ser parte integral del repertorio de aplicaciones
HPC~\cite{gpu-computing}.
Un hito importante en esta tendencia fue la aparición, en noviembre de 2008, del
primer clúster basado en GPUs en la lista Top500, un ránking semestral de los
500 supercomputadores más poderosos del mundo~\cite{top500}.

A medida que las GPUs se hacían más programables, también evolucionaron las
interfaces para programación.  Inicialmente, los procesadores de
vértices y de fragmentos debían ser programados a nivel de lenguaje de
ensamblado.
Después aparecieron lenguajes de más alto nivel como Cg, HLSL y GLslang,
que sin embargo aún utilizaban llamadas explícitas a las APIs gráficas.
Debido a esto, la implementación de algoritmos de propósito general
requería expresarlos en función de directivas gráficas~\cite[\S2.2]{brookgpu}.
Programar la GPU implicaba crear shaders, programas que pintan píxeles a partir
de los vértices, fragmentos y texturas que le sirven de entrada.

Las abstracciones gráficas (vértices, fragmentos, texturas, shaders)
son análogas a un paradigma más general denominado \emph{stream processing},
en que una serie de operaciones de cómputo (los kernels) son aplicados sobre
cada elemento de un conjunto de datos de entrada (el stream).  Este modelo es
incorporado en lenguajes para GPUs más recientes como Brook y CUDA.

A pesar de ofrecer modelos de programación cada vez más flexibles,
las GPUs siguen siendo un entorno de programación extremadamente limitado,
y no cualquier algoritmo es apropiado para ser acelerado en la GPU.
En particular, la programación usando streams
incentiva aplicaciones con alta intensidad aritmética
(tasa de operaciones por ancho de banda de memoria)~\cite[\S2.1]{brookgpu}.
Operaciones que son elementales en la CPU, como
ejecución condicional y acceso directo a memoria, no permiten explotar el
paralelismo y el ancho de banda de la GPU, e introducen penalizaciones de
rendimiento importantísimas~\cite[\S{}V.C]{gpu-computing}.

\subsection{Programación científica de alto nivel y las GPUs}
La programación de aplicaciones de ciencia e ingeniería se caracteriza por sus
exigentes requerimientos de performance.  Las bibliotecas científicas suelen
estar implementadas en lenguajes compilados, típicamente C y Fortran, cuyos
compiladores realizan optimizaciones agresivas que permiten obtener binarios
extremadamente eficientes en términos de tiempo de ejecución, aprovechando al
máximo la arquitectura del computador.

Por otra parte, existen los lenguajes de programación dinámicos (p.ej.~Lisp,
Python, Ruby, Scheme) que están diseñados para aumentar la eficiencia
del programador.  Permiten ciclos de desarrollo más rápido, presentan
abstracciones más cercanas al problema que a la máquina, y ofrecen
facilidades de metaprogramación~\cite[\S2]{pygpu}.  Como consecuencia, los
programas suelen ser más fáciles de implementar, de mantener y de reutilizar,
y se adaptan mejor al esquema de trabajo de un programador científico,
típicamente orientado a refinar prototipos en varias iteraciones.

El precio del dinamismo es una altísima penalización en rendimiento.  Por esto,
los entornos de programación científicos dinámicos están diseñados para servir
de pegamento entre bibliotecas binarias altamente optimizadas.  Este esquema es
utilizado exitosamente, por ejemplo, por el lenguaje Matlab y por la biblioteca
Numpy en el lenguaje Python, lo que permite desarrollar aplicaciones científicas
completas de rendimiento aceptable sin necesidad de escribir código en un
lenguaje compilado.

Muy recientemente han aparecido sistemas para integrar la programación de GPUs
de manera transparente en lenguajes de alto nivel.

GPU++~\cite{gpupp} (2007) es un sistema de desarrollo integrado con C++ que
permite implementar y utilizar kernels abstrayendo tanto la GPU como la CPU.
Introduce varias técnicas de optimización, y administra en lugar del programador
la ejecución de código y el copiado de datos entre el procesador y la tarjeta
gráfica.

PyGPU~\cite{pygpu} (2008) es una biblioteca para escribir funciones para la
GPU en Python. Utiliza las capacidades introspectivas del lenguaje,
introduciendo un decorador que examina el bytecode de la función y anotaciones
adicionales, y compila el código para la GPU.

PyCUDA~\cite{pycuda} (2008) es una biblioteca que permite acceder directamente a
la API de CUDA desde Python, ofreciendo además varias conveniencias adicionales,
como una estructura de datos para representar matrices y vectores, cuyas
operaciones son ejecutadas transparentemente en la GPU.

Además, entornos comerciales de programación científica como Mathematica y
Matlab también han comenzado a ofrecer integración transparente con GPUs~%
\cite{nvidia-mathematica}~\cite{nvidia-matlab}.


\subsection{Dinámica de fluídos computacional}
Una de las áreas de investigación que tradicionalmente ha tenido requerimientos
exigentes de poder de cómputo para sus simulaciones es la dinámica de fluídos.
La dinámica de fluídos computacional tiene importantes aplicaciones industriales
en diversas áreas como la aeronáutica, la meteorología y la geología.

La dinámica de fluídos estudia los fluídos en movimiento.  Los problemas de la
dinámica de fluídos consisten en calcular varias propiedades del fluído (p.ej.
la velocidad $\vel$, la presión $p$, la densidad $\rho$, la temperatura $T$) en
todo el dominio del fluido, durante un intervalo de tiempo.  Estas propiedades
se llaman variables de estado, y están relacionadas por leyes de conservación y
ecuaciones de estado, que están expresadas como ecuaciones diferenciales parciales.

En general los problemas de dinámica de fluídos no se pueden resolver
analíticamente excepto en casos triviales.  La dinámica de fluídos computacional
(CFD) usa métodos numéricos para resolver estos problemas, que aun así siguen
siendo complejos:  incluso con ecuaciones simplificadas y usando recursos de
HPC, sólo es posible obtener soluciones aproximadas.

La ecuación más importante de la dinámica de fluídos es la ecuación de
Navier-Stokes, que describe la conservación de momentum en un fluido viscoso,
de manera análoga a la segunda ley de Newton.  
\begin{equation}
    \rho\left(\frac{\partial\vel}{\partial t} + \vel\cdot\nabla\vel \right) =
    \text{fuerza por unidad de volumen}.
    %\nu\Delta\vel - \nabla p + \mathbf{f}.
\end{equation}
El término $\rho(\vel\cdot\nabla\vel)$ es denominado aceleración convectiva, y
explica cómo cambia la velocidad con respecto a la posición en un instante de
tiempo fijo.  Este es el único término no lineal de la ecuación, lo que acarrea
problemas numéricos al discretizar el problema, y en la práctica representa el
principal aporte a la turbulencia del fluído.

La turbulencia es el comportamiento caótico observado en los fluídos.  Es un
fenómeno cuya naturaleza no está bien comprendida, y es difícil de cuantificar y
de describir.  Los métodos numéricos para fluídos turbulentos deben incorporar
algún tipo de modelo de turbulencia, generalmente con base experimental, para
dar cuenta de ella.  Además, la turbulencia emerge en varios niveles de escala,
lo que exige alta resolución en la discretización de los problemas, y por lo
tanto más poder computacional.

\subsection{Métodos de partículas}
La mayoría de los métodos de CFD discretizan el dominio del problema utilizando
algún tipo de malla.  Los métodos de partículas, en cambio, son una clase
de métodos que utilizan partículas discretas que arrastran distribuciones
localizadas de variables de estado por el fluído.  Las propiedades físicas del
fluído pueden ser recuperadas como una superposición de las distribuciones
de todas las partículas.

Las métodos de partículas están basados en la formulación en coordenadas
lagrangianas de las ecuaciones subyacentes.  La forma lagrangiana utiliza como
marco de referencia las trayectorias de las partículas en el tiempo, y en ella
no aparece el término de aceleración convectiva.  Las ecuaciones pasan a ser un
sistema de ecuaciones diferenciales ordinarias:
\begin{align}
    \frac{d\pos_p}{dt} &= \vel_p(\pos_p, t) =
        \sum_{p'} \mathbf{K}(\pos_p, \pos_{p'}; \xi_p, \xi_{p'}), &
    \frac{d\xi_p}{dt} &=
        \sum_{p'} \mathbf{F}(\pos_p, \pos_{p'}; \xi_p, \xi_{p'});
\end{align}
donde $\xi$ es alguna propiedad del fluído, y $\mathbf{K}$ y $\mathbf{F}$ 
representan la dinámica del sistema físico simulado.

Una clase importante de métodos de partículas son los métodos de vórtices (VM),
que han sido utilizados desde la década de 1930 para describir la evolución de
estructuras vorticales en flujos incompresibles~\cite[\S2.2]{multiscale}.  Los
VMs describen la evolución de la vorticidad $\vort = \nabla\times\vel$ del
fluído.  En cada iteración, es necesario recuperar la velocidad a partir de la
vorticidad para avanzar las partículas, y este paso es el más costoso en
términos computacionales.  Por otra parte, en muchos fluídos la vorticidad es
no nula sólo en una región reducida del dominio, lo que permite reducir el
número de partículas necesarias para la simulación.

Los métodos de vórtices han sido utilizados en aplicaciones de ingeniería,
sus resultados tienen buena concordancia con los experimentos, y se ha postulado
que su utilización introduce un modelo de turbulencia implícito.

Los métodos de partículas no fueron muy utilizados en la simulación de sistemas
continuos debido a dificultades numéricas y de implementación.  Trabajos
teóricos recientes han abordado exitosamente los problemas numéricos, y han
demostrado las ventajas de estos métodos:  adaptividad, capacidad de
multiresolución, estabilidad de la discretización y un nexo inherente entre
la simulación y el fenómeno físico subyacente~\cite{ppm}.

Un resultado teórico importante es la necesidad de reubicar periódicamente
las partículas sobre una malla regular para asegurar la convergencia.  Esto ha
dado origen a los métodos híbridos partícula-malla, que además de evitar la
distorsión de las partículas, permite integrar los métodos de partículas con
algoritmos eficientes diseñados sobre grillas~\cite[\S3]{multiscale}.

Otro aspecto importante en el que ha habido resultados importantes recientes es
en las simulaciones de partículas con varios niveles de resolución.
Se ha propuesto esquemas que utilizan
partículas con tamaños variables,
mapeos adaptivos globales,
refinamientos adaptivos de malla
y análisis multiresolución usando wavelets~\cite{multiresolution}.

Todas estas características adicionales, que apuntan a lograr un balance
conveniente entre precisión y tiempo de cómputo, complementan el framework 
genérico para describir los métodos de partículas.  En general, cada iteración
de una simulación tiene algunas etapas fijas, que están relacionadas con
diferentes aspectos del fluído: la convección, la difusión, la satisfacción de
las condiciones de borde, la adaptación espacial, y (para los métodos de vórtices)
la evaluación de la velocidad.  Para cada una de estas etapas, existen varios
modelos que pueden ser usados:  por ejemplo, para la convección, se puede
utilizar cualquier esquema de integración numérica de EDOs;  para la difusión, 
se ha propuesto por lo menos siete esquemas diferentes~\cite[\S1.2]{barba}.

Hasta hace algunos años, la escasez de bibliotecas científicas relevantes y la
dificultad de paralelizar eficientemente estos métodos fueron problemas que
impidieron su implementación eficiente.  Recientemente, el ETH de Zúrich desarrolló una
biblioteca paralela para métodos partícula-malla que facilita implementarlos
eficientemente sobre arquitecturas paralelas de gran escala~\cite{ppm}.

También ha habido trabajos recientes con simulaciones de fluídos usando partículas
en GPUs, principalmente en el área de computación gráfica.  Los métodos usados
para visualización sólo buscan conseguir realismo visual, y no resuelven con
exactitud las ecuaciones que discretizan.  Una implementación de un método de
vórtices publicada en julio de 2008 asegura ser la primera simulación de fluídos
exacta usando partículas en la GPU~\cite{vortex-gpu}.  Esta implementación está
descrita en función de directivas gráficas, mapeando las partículas a texturas,
en las que cada canal de color representa las propiedades de las partículas, y
expresando los pasos del algoritmo como shaders del pipeline gráfico.

%Los VMs resuelven la ecuación de Navier-Stokes en su formulación
%velocidad-vorticidad:
%\begin{equation}
%    \frac{\partial\vort}{\partial t} + (\vel\cdot\nabla)\vort =
%    (\vort\cdot\nabla)\vel + \nu\Delta\vort,
%\end{equation}
%donde $\mathbf{u}$ es la velocidad
%y $\vort = \nabla\times\mathbf{u}$ es la vorticidad.  La velocidad se obtiene
%resolviendo la ecuación de Poisson: $\Delta\vel u = -\nabla\times\vort$


\subsection{Propuesta de tesis}

Este proyecto de tesis consiste en el análisis, diseño e implementación de un
prototipo de una biblioteca para hacer simulaciones de fluídos con las
siguientes características:
\begin{itemize}
    \item el modelo utilizado será el framework genérico de métodos de
       partículas propuesto y descrito por Koumoutsakos~\cite{multiscale}.
    \item los componentes de la simulación serán implementados en el lenguaje de
        programación dinámico Python;
    \item la simulación será acelerada transparentemente en hardware gráfico;
    \item 
\end{itemize}
El propósito de esta biblioteca es servir de prueba de concepto para el
desarrollo de bibliotecas de propósito específico, en lenguajes de alto nivel,
que puedan explotar eficiente y transparentemente el hardware paralelo disponible.

La factibilidad de implementar eficientemente métodos de partículas en hardware
gráfico está sustentada por el trabajo de Rossinelli y Koumoutsakos, que
describe un método de vórtices preciso y eficiente implementado en una
GPU~\cite{vortex-gpu}.

La factibilidad de integrar transparentemente la GPU con lenguajes de
programación de propósito general a través de abstracciones de alto nivel está
sustentada en varios desarrollos recientes, como los mencionados
GPU++~\cite{gpupp}, PyGPU~\cite{pygpu} y PyCUDA~\cite{pycuda}.

El modelo de ejecución de la GPU no incentiva el desarrollo de componentes
totalmente desacoplados.  Como la compilación de los kernels se realiza en tiempo
de ejecución, y cargar los streams de datos es muy costoso, conviene
que toda la simulación sea cargada en la GPU de manera unificada.  Para
implementar eficientemente componentes desacoplados e intercambiables, la
la simulación no debe ser descrita algorítmicamente, sino declarativamente.  En
lenguajes de alto nivel, es posible combinar ambos enfoques usando mecanismos de
metaprogramación e introspección.  La factibilidad de utilizar estas técnicas
está sustentada en bibliotecas que hacen uso de ellas, como OpenFOAM~(en C++,
para simulaciones de fluidos)~\cite{openfoam} y PyGPU~(en Python, para
procesamiento de imágenes)~\cite{pygpu}.







%La tendencia en los entornos de programación de GPUs es a ofrecer interfaces
%cada vez más genéricas, de modo de poder ser utilizadas para escribir programas
%de propósito general.  Esto puede ser descrito como un acercamiento bottom-up
%al desarrollo de software de alto desempeño:  partiendo del hardware gráfico,
%se crean las abstracciones que serán utilizadas para crear programas.
%
%Esta tesis intenta explorar un acercamiento top-down, enfocado a un dominio de
%problema específico: cómo diseñar una biblioteca de alto nivel, en un lenguaje
%de características dinámicas, cuyos componentes puedan correr en la GPU de
%manera transparente al programador.  La idea es que las abstracciones provistas
%por la interfaz estén en el dominio de los métodos de partículas.
%
%Como producto final se espera presentar una pequeña biblioteca que sirva de
%prueba de concepto para el desarrollo de aplicaciones aceleradas por GPU en un
%dominio particular, evaluando el impacto en performance y complejidad de
%programación de las decisiones de diseño tomadas.
%
%Con el fin de acotar el número de factores involucrados, el trabajo de tesis se
%enfocará en la implementación de métodos de vórtices en dos dimensiones.  Varios
%tipos de componentes pueden ser integrados en un método de este tipo; por
%ejemplo: diferentes condiciones de borde, diferentes modelos de difusión,
%distintos modelos de multiresolución, y diferentes métodos para evaluar la
%velocidad a partir de la vorticidad.


\newpage
\begin{thebibliography}{99}
    \bibitem{gpu-computing}
    John D.~Owens et~al.
    \reftitle{GPU Computing.}
    Proceedings of the IEEE, May 2008, 879--899.

    \bibitem{multiresolution}
    Michael Bergdorf, Petros Koumoutsakos.
    \reftitle{Multiresolution Particle Methods.}
    Complex Effects in Large Eddy Simulations, 56~(2006) 49--61.

    \bibitem{multiscale}
    Petros Koumoutsakos.
    \reftitle{Multiscale Flow Simulations Using Particles.}
    Annu.~Rev. Fluid~Mech. 37~(2005) 457--487.

    \bibitem{ppm}
    I.F.~Sbalzarini et~al.
    \reftitle{PPM -~A highly efficient parallel particle-mesh library
      for the simulation of continuum systems.}
    Journal of Computational Physics 215~(2006) 566--588.

    \bibitem{vortex-gpu}
    Diego Rossinelli, Petros Koumoutsakos.
    \reftitle{Vortex methods for incompressible flow simulations on the GPU.}
    Visual Comput~(2008).

    \bibitem{barba}
    Lorena Barba.
    \reftitle{Vortex Method for computing high-Reynolds number flows:
    Increased accuracy with a fully mesh-less formulation.}
    Tesis doctoral, California Institute of Technology, 2004.

    \bibitem{gpupp}
    Thomas C.~Jansen.
    \reftitle{GPU++: An Embedded GPU Development System for
      General-Purpose Computations.}
    Tesis doctoral, Technischen Universität München, 2007.

    \bibitem{pygpu}
    Calle Lejdfors.
    \reftitle{High-level GPU programming: Domain-specific optimization and inference.}
    Tesis doctoral, Lund University, 2008.

    \bibitem{brookgpu}
    Ian Buck et~al.
    \reftitle{Brook for GPUs: Stream Computing on Graphics Hardware.}
    Stanford University.

    \bibitem{parallel-programming}
    Barry Wilkinson, Michael Allen.
    \reftitle{Parallel Programming.}
    Pearson Prentice Hall, 2nd Edition, 2005.

    \bibitem{nvidia-mathematica}
    Nvidia Press Release.
    \reftitle{Mathematica Users Get 100x Performance Boost From NVIDIA CUDA.}
    \url{http://www.nvidia.com/object/io_1227010734073.html}

    \bibitem{nvidia-matlab}
    Nvidia Developer Zone.
    \reftitle{MATLAB plug-in for CUDA.}
    \url{http://developer.nvidia.com/object/matlab_cuda.html}

    \bibitem{top500}
    \reftitle{Top500 Supercomputing Sites.}
    \url{http://www.top500.org}

    \bibitem{openfoam}
    OpenCFD Ltd.
    \reftitle{OpenFOAM, The Open Source CFD Toolbox.}
    \url{http://www.opencfd.co.uk/openfoam/}

    \bibitem{pycuda}
    Andreas Klöckner.
    \reftitle{PyCUDA.}
    \url{http://mathema.tician.de/software/pycuda}

    \bibitem{hpc-gpu-cuda-slides}
    HPC GPU CUDA slides.

\end{thebibliography}

\newpage
\section{Hipótesis de Trabajo}
\begin{enumerate}
    \item Implementación
    \item La biblioteca
    \item La implementación de los componentes de los métodos de partículas
        abstraerá completamente los detalles de la GPU.  abstraerá completamente los
        detalles de la GPU.
    \item Las simulaciones 
\end{enumerate}

\newpage
\section{Objetivos }

\subsection{Objetivos Generales}
%\emph{(Su extensión no debe exceder el espacio disponible)}

\begin{enumerate}
    \item Explorar la posibilidad de desarrollar bibliotecas de software de
        propósito específico que aprovechen arquitecturas de hardware paralelas
        de manera transparente.
    \item 
\end{enumerate}

\subsection{Objetivos Específicos}
%\emph{(Su extensión no debe exceder el espacio disponible) }

\begin{enumerate}
   \item Evaluar mecanismos de comunicación entre un lenguaje de programación
       dinámico y el hardware gráfico, en términos de rendimiento computacional y
       conveniencia para el desarrollador.
   \item Diseñar e implementar un prototipo de biblioteca
       para simulaciones de fluídos mediante métodos de partículas,
       en un lenguaje de programación dinámico,
       basada en componentes intercambiables,
       y acelerada en hardware gráfico.
   \item 
\end{enumerate}

\newpage
\section{Metodología y Plan de Trabajo}
\emph{(Su extensión no debe exceder el espacio disponible)}

 \newpage
\section{Resultados}

\subsection{Aportes y Resultados Esperados}

\begin{enumerate}
    \item Una biblioteca que 
    \item Ganancia de performance
    \item Metodología
    \item Publicación de artículos en workshops o conferencias internacionales
        relacionadas con computación de alto desempeño, dinámica de fluídos
        computacional y lenguajes de programación dinámicos.
\end{enumerate}
 

\subsection{Formas de Validación}

\emph{(Su extensión no debe exceder el espacio disponible)}

\begin{enumerate}
    \item
    \item
    \item
\end{enumerate}
 

\section{Recursos}

\subsection{Recursos disponibles}

%\emph{Señale medios y recursos con que cuenta el Departamento de Informática de
%la UTFSM, para realizar el proyecto de tesis (libros, software, laboratorios,
%etc.).}

Los recursos de hardware y software del Laboratorio de Métodos Cuantitativos
están a disposición para el desarrollo de este proyecto.

\subsection{Recursos solicitados}

%\emph{Señale medios y recursos no disponibles en el Departamento de Informática
%de la UTFSM, necesarios para realizar el proyecto de tesis (libros, software,
%laboratorios, etc. ). Su extensión no debe exceder el espacio disponible}

XXX








%\section*{Abstract}
%Stream computing is a parallel computing paradigm in which large streams of data
%flow through kernel functions, capable of performing non-trivial operations in
%parallel. Streaming architectures achieve high-troughput by exploiting
%algorithms that exhibit high arithmetic intensity.
%
%This paradigm is well-suited for computation on commodity graphic hardware.
%Current graphic processing units are agressively pipelined processors, and are
%capable to perform general-purpose floating-point computation with one order of
%magnitude better performance than CPUs. Vendor-provided APIs are moving from
%supporting only graphic-related operations towards more generic programming
%models.
%
%Still, GPUs still offer a very restricted programming model. Currently there is
%active development in order to integrate streaming low-level APIs into
%higher-level programming languages, including highly dynamic languages. Several
%different approaches have been implemented, allowing to exploit agressive
%parallelism, while keeping the advantages of high-level development.
%
%As opposed to these frameworks, that aim at providing a generic set of operations
%suitable for a wide class of algorithms, this work explores the design of
%high-level stream-computing operations specifically for implementing particle
%methods in fluid dynamics, tailored to tackle the performance bottlenecks of
%this kind of methods.
%
%Particle methods solve transport problems by advecting discrete particles that
%carry the transported quantities, in order to solve the governing equations in
%their Lagrangian form. As all computational fluid dynamics techniques, these
%methods require large computational power, and can enjoy significant speedups by
%exploiting parallelism.
%
%A top-down approach for this specific domain will be adopted, by decomposing
%high-level implementations into parts that are suitable for being parallelized,
%taking into account the perfomance tradeoffs implied with each decision.

\end{document}
% Observaciones y sugerencias
% 1. No esta claro por que hacer esto. Cuales son los beneficios que se esperan.
% 2. ¿Por que las otras propuestas no son adecuadas para el particle methods?
% 3. Me llama la atencion que se plantee una tesis de Doctorado para un prob-
%    lema particular. Que de interesante tiene este problema ?, ¿ es facil ex-
%    tender la solucion a otros problemas en otrosambitos?
% 4. Plantear claramente las hipotesis.
% 5. En la presentacion considerar referencias bibliograficas que avalen la prop-
%    uesta, es decir, que justifiquen la necesiddad (si es que existen).
